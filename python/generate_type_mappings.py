"""
Generate type mappings.

This script is used to generate a mapping between the format of types found in
LDC annotations and an AIF knowledge base.

The example output file generated by this script is given below:

annotation_type    aif_type
conflict.attack.airstrikemissilestrike    Conflict.Attack.AirstrikeMissileStrike

The output mapping file will be used as input by the AIF generator, a script the
takes LDCs annotations and produces AIF knowledge base in turtle-RDF format.
"""

__author__  = "Shahzad Rajput <shahzad.rajput@nist.gov>"
__status__  = "production"
__version__ = "0.0.0.1"
__date__    = "12 February 2020"

from aida.logger import Logger
from aida.ontology import Ontology

import argparse
import os
import sys

ALLOK_EXIT_CODE = 0
ERROR_EXIT_CODE = 255

def check_if_path_exists(args):
    for path in [args.log_specifications_filename, 
                 args.entities_ontology_filename,
                 args.relations_ontology_filename,
                 args.events_ontology_filename,
                 ]:
        if not os.path.exists(path):
            print('Error: Path {} does not exist'.format(path))
            exit(ERROR_EXIT_CODE)

def main(args):    
    check_if_path_exists(args)
    logger = Logger(args.log, args.log_specifications_filename, sys.argv)
    ontology = Ontology(logger, args.entities_ontology_filename, args.relations_ontology_filename, args.events_ontology_filename)
    mapping = {}    
    for ere_container in [ontology.get('entities'), ontology.get('relations'), ontology.get('events')]:
        for spec in ere_container.values():
            full_type = spec.get('cleaned_full_type')
            full_type_ov = spec.get('cleaned_full_type_ov')
            if full_type is None or full_type_ov is None:
                continue
            mapping[full_type_ov] = full_type

    program_output = open(args.output_filename, 'w')
    program_output.write('full_type_ov\tfull_type\n')
    for full_type_ov, full_type in mapping.items():
        program_output.write('{}\t{}\n'.format(full_type_ov, full_type))
    program_output.close()
    exit(ALLOK_EXIT_CODE)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Generate type mappings.")
    parser.add_argument('-l', '--log', default='log.txt', 
                        help='Specify a file to which log output should be redirected (default: %(default)s)')
    parser.add_argument('-v', '--version', action='version', version='%(prog)s ' + __version__, 
                        help='Print version number and exit')
    parser.add_argument('log_specifications_filename', type=str,
                        help='File containing error specifications')
    parser.add_argument('entities_ontology_filename', type=str,
                        help='File containing ontology of entities')
    parser.add_argument('relations_ontology_filename', type=str,
                        help='File containing ontology of reltions')
    parser.add_argument('events_ontology_filename', type=str,
                        help='File containing ontology of events')
    parser.add_argument('output_filename', type=str,
                        help='Specify a file to which output should be written')
    args = parser.parse_args()
    main(args)